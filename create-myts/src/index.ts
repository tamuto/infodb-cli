import prompts from 'prompts';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { spawn } from 'node:child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface PromptResponse {
  projectName: string;
  template: 'basic' | 'cli' | 'server' | 'library';
}

interface TemplateInfo {
  description: string;
  projectStructure: string;
  extraInfo: string;
}

const templateInfo: Record<'basic' | 'cli' | 'server' | 'library', TemplateInfo> = {
  basic: {
    description: 'A basic TypeScript project created with create-myts.',
    projectStructure: '- `src/` - TypeScript source files\n- `dist/` - Compiled JavaScript (generated by build)',
    extraInfo: ''
  },
  cli: {
    description: 'A CLI application created with create-myts.',
    projectStructure: '- `bin/cli.js` - Executable entry point\n- `src/` - TypeScript source files\n- `dist/` - Compiled JavaScript (generated by build)',
    extraInfo: `
## Publishing Your CLI

To publish your CLI to npm:

1. Update \`package.json\` with your package details
2. Make sure the \`bin\` field points to your executable
3. Build your project: \`npm run build\`
4. Publish: \`npm publish\`

After publishing, users can install and use your CLI:

\`\`\`bash
npm install -g {{projectName}}
{{projectName}}
\`\`\``
  },
  server: {
    description: 'An HTTP server application created with create-myts.',
    projectStructure: '- `src/server.ts` - HTTP server implementation\n- `dist/` - Compiled JavaScript (generated by build)',
    extraInfo: `
## API Endpoints

The default template includes a basic example endpoint:

- \`GET /\` - Returns a welcome message

## Additional Configuration

You can create a \`.env\` file in the project root to store configuration (already in .gitignore).`
  },
  library: {
    description: 'A TypeScript library created with create-myts.',
    projectStructure: '- `src/` - TypeScript source files\n- `dist/` - Compiled JavaScript with type declarations (generated by build)',
    extraInfo: `
## Publishing Your Library

Before publishing to npm:

1. Update \`package.json\` with appropriate metadata
2. Build your library: \`npm run build\`
3. Test locally using \`npm link\`
4. Publish: \`npm publish\`

After publishing, users can install and use your library:

\`\`\`bash
npm install {{projectName}}
\`\`\`

\`\`\`typescript
import { /* your exports */ } from '{{projectName}}';
\`\`\``
  }
};

async function main() {
  console.log('\nWelcome to create-myts!\n');

  const response = await prompts([
    {
      type: 'text',
      name: 'projectName',
      message: 'Project name:',
      initial: 'my-project',
      validate: (value: string) => {
        if (!value) return 'Project name is required';
        if (!/^[a-z0-9-_]+$/.test(value)) {
          return 'Project name can only contain lowercase letters, numbers, hyphens, and underscores';
        }
        return true;
      }
    },
    {
      type: 'select',
      name: 'template',
      message: 'Select a template:',
      choices: [
        { title: 'basic', value: 'basic', description: 'Minimal TypeScript setup with tsc' },
        { title: 'cli', value: 'cli', description: 'CLI application template' },
        { title: 'server', value: 'server', description: 'HTTP server template' },
        { title: 'library', value: 'library', description: 'Library template' }
      ],
      initial: 0
    }
  ]) as PromptResponse;

  if (!response.projectName || !response.template) {
    console.log('\nOperation cancelled.');
    process.exit(1);
  }

  const { projectName, template } = response;
  const targetDir = path.join(process.cwd(), projectName);

  // Check if directory already exists
  if (fs.existsSync(targetDir)) {
    console.error(`\nError: Directory "${projectName}" already exists.`);
    process.exit(1);
  }

  // Get template source directory
  // When built, __dirname will be in 'dist', so templates are at ../templates
  const templatesDir = path.join(__dirname, '..', 'templates');
  const templateSource = path.join(templatesDir, template);

  if (!fs.existsSync(templateSource)) {
    console.error(`\nError: Template "${template}" not found.`);
    process.exit(1);
  }

  try {
    // Copy template to target directory
    console.log(`\nScaffolding project in ${targetDir}...`);
    fs.cpSync(templateSource, targetDir, { recursive: true });

    // Copy common files from _common directory
    const commonDir = path.join(templatesDir, '_common');
    if (fs.existsSync(commonDir)) {
      const commonFiles = fs.readdirSync(commonDir);
      for (const file of commonFiles) {
        const srcPath = path.join(commonDir, file);
        const destPath = path.join(targetDir, file);
        fs.cpSync(srcPath, destPath, { recursive: true });
      }
    }

    // Update package.json with project name
    const packageJsonPath = path.join(targetDir, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
      packageJson.name = projectName;
      fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
    }

    // Rename _gitignore to .gitignore
    const gitignoreSource = path.join(targetDir, '_gitignore');
    const gitignoreTarget = path.join(targetDir, '.gitignore');
    if (fs.existsSync(gitignoreSource)) {
      fs.renameSync(gitignoreSource, gitignoreTarget);
    }

    // Update README.md with project-specific information
    const readmePath = path.join(targetDir, 'README.md');
    if (fs.existsSync(readmePath)) {
      const info = templateInfo[template];
      let readme = fs.readFileSync(readmePath, 'utf-8');
      readme = readme.replace(/\{\{projectName\}\}/g, projectName);
      readme = readme.replace(/\{\{description\}\}/g, info.description);
      readme = readme.replace(/\{\{projectStructure\}\}/g, info.projectStructure);
      readme = readme.replace(/\{\{extraInfo\}\}/g, info.extraInfo);
      fs.writeFileSync(readmePath, readme);
    }

    const packageManager = detectPackageManager();

    console.log('\nDone! Now run:\n');
    console.log(`  cd ${projectName}`);
    console.log(`  ${packageManager} install`);
    console.log(`  ${packageManager} run dev`);
    console.log('');

    // Optional: Auto install dependencies
    const { autoInstall } = await prompts({
      type: 'confirm',
      name: 'autoInstall',
      message: 'Install dependencies now?',
      initial: true
    });

    if (autoInstall) {
      console.log('\nInstalling dependencies...\n');
      await installDependencies(targetDir);
      console.log('\nDependencies installed successfully!\n');
      console.log('Run the following to get started:\n');
      console.log(`  cd ${projectName}`);
      console.log(`  ${packageManager} run dev`);
      console.log('');
    }
  } catch (error) {
    console.error('\nError creating project:', error);
    process.exit(1);
  }
}

function detectPackageManager(): 'npm' | 'pnpm' | 'yarn' {
  const userAgent = process.env.npm_config_user_agent || '';

  if (userAgent.includes('pnpm')) {
    return 'pnpm';
  } else if (userAgent.includes('yarn')) {
    return 'yarn';
  } else {
    return 'npm';
  }
}

function installDependencies(cwd: string): Promise<void> {
  const packageManager = detectPackageManager();

  return new Promise((resolve, reject) => {
    const child = spawn(packageManager, ['install'], {
      cwd,
      stdio: 'inherit',
      shell: true
    });

    child.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`${packageManager} install exited with code ${code}`));
      } else {
        resolve();
      }
    });

    child.on('error', (err) => {
      reject(err);
    });
  });
}

main().catch((error) => {
  console.error('An error occurred:', error);
  process.exit(1);
});
