import { promises as fs } from 'fs';
import path from 'path';
import { LambdaConfig } from './config';
import { Logger } from './logger';

export class ScriptGenerator {
  constructor(private logger: Logger) {}

  generateDeployScript(functionName: string, config: LambdaConfig): string {
    const script = `#!/bin/bash
set -eu

# Generated by lctl - Lambda Control Tool
# Function: ${functionName}
# Generated at: ${new Date().toISOString()}

${this.generateZipSection(config)}${this.generateEnvironmentVariablesSection(config)}${this.generateLayersSection(config)}# Lambda関数の存在を確認
if aws lambda get-function --function-name ${functionName} &> /dev/null; then
    echo "Updating existing Lambda function: ${functionName}"
    aws lambda update-function-code --function-name ${functionName} --zip-file fileb://lambda.zip | jq .

    # 設定の更新
    aws lambda update-function-configuration --function-name ${functionName} \\
        --runtime ${config.runtime} \\
        --handler ${config.handler} \\
        --role ${config.role} \\
        --timeout ${config.timeout || 3} \\
        --memory-size ${config.memory || 128} \\
        --architectures ${config.architecture || 'x86_64'}${this.generateEnvironmentVariablesFlag(config)}${this.generateLayersFlag(config)} | jq .
else
    echo "Creating new Lambda function: ${functionName}"
    aws lambda create-function --function-name ${functionName} \\
        --zip-file fileb://lambda.zip \\
        --handler ${config.handler} \\
        --runtime ${config.runtime} \\
        --architectures ${config.architecture || 'x86_64'} \\
        --timeout ${config.timeout || 3} \\
        --memory-size ${config.memory || 128} \\
        --role ${config.role}${this.generateEnvironmentVariablesFlag(config)}${this.generateLayersFlag(config)}${this.generateDescriptionFlag(config)} | jq .
fi

# 共通の追加設定
${this.generateAdditionalConfigurationCommands(functionName, config)}

${this.generatePermissionsSection(functionName, config)}

${this.generateLogGroupSection(functionName, config)}

rm lambda.zip

echo "✅ Lambda function ${functionName} deployed successfully!"
`;

    return script;
  }


  private generateZipSection(config: LambdaConfig): string {
    let section = '# Create deployment package\n';
    const functionsDir = config.functionsDirectory || 'functions';
    
    // Change to functions directory
    section += `cd ${functionsDir}\n`;
    
    if (config.files && config.files.length > 0) {
      // Custom file list
      section += 'echo "Creating deployment package..."\n';
      section += 'rm -f lambda.zip\n';

      for (const file of config.files) {
        if (file.includes('*')) {
          // Glob pattern - use find for bash compatibility
          section += `find . -path "${file}" -type f | zip -@ lambda.zip\n`;
        } else {
          section += `zip -r lambda.zip "${file}"\n`;
        }
      }
    } else {
      // Default: zip current directory with excludes from config
      section += 'echo "Creating deployment package from functions directory..."\n';
      const excludes = config.zip_excludes || ['*.git*', 'node_modules/*', '*.zip', 'dist/*', '.DS_Store'];
      const excludeArgs = excludes.map(exclude => `"${exclude}"`).join(' ');
      section += `zip -r lambda.zip . -x ${excludeArgs}\n`;
    }
    
    // Move ZIP back to project root
    section += `mv lambda.zip ../\n`;
    section += `cd ..\n`;

    section += '\n';
    return section;
  }

  private generateEnvironmentVariablesSection(config: LambdaConfig): string {
    if (!config.environment || Object.keys(config.environment).length === 0) {
      return '';
    }

    let section = '# Environment Variables\n';
    section += 'ENVIRON="Variables={"\n';

    const envVars = Object.entries(config.environment);
    envVars.forEach(([key, value], index) => {
      section += `ENVIRON+="${key}=${value}`;
      if (index < envVars.length - 1) {
        section += ',';
      }
      section += '"\n';
    });

    section += 'ENVIRON+="}"\n\n';
    return section;
  }

  private generateLayersSection(config: LambdaConfig): string {
    if (!config.layers || config.layers.length === 0) {
      return '';
    }

    let section = '# Layers\n';
    section += `LAYERS="${config.layers.join(' ')}"\n\n`;
    return section;
  }

  private generateEnvironmentVariablesFlag(config: LambdaConfig): string {
    if (!config.environment || Object.keys(config.environment).length === 0) {
      return '';
    }
    return ' \\\n        --environment "$ENVIRON"';
  }

  private generateLayersFlag(config: LambdaConfig): string {
    if (!config.layers || config.layers.length === 0) {
      return '';
    }
    return ' \\\n        --layers $LAYERS';
  }

  private generateDescriptionFlag(config: LambdaConfig): string {
    if (!config.description) {
      return '';
    }
    return ` \\\n        --description "${config.description}"`;
  }

  private generateAdditionalConfigurationCommands(functionName: string, config: LambdaConfig): string {
    let commands = '';

    // Reserved concurrency
    if (config.reserved_concurrency !== undefined) {
      commands += `\n# Set reserved concurrency\n`;
      commands += `aws lambda put-reserved-concurrency-capacity --function-name ${functionName} --reserved-concurrency-capacity ${config.reserved_concurrency} | jq .\n`;
    }

    // VPC configuration
    if (config.vpc) {
      commands += `\n# Update VPC configuration\n`;
      commands += `aws lambda update-function-configuration --function-name ${functionName} \\
        --vpc-config "SubnetIds=${config.vpc.subnets.join(',')},SecurityGroupIds=${config.vpc.security_groups.join(',')}" | jq .\n`;
    }

    // Dead letter queue
    if (config.dead_letter_queue) {
      commands += `\n# Set dead letter queue\n`;
      commands += `aws lambda update-function-configuration --function-name ${functionName} \\
        --dead-letter-config "TargetArn=${config.dead_letter_queue.target_arn}" | jq .\n`;
    }

    // Ephemeral storage
    if (config.ephemeral_storage) {
      commands += `\n# Set ephemeral storage\n`;
      commands += `aws lambda update-function-configuration --function-name ${functionName} \\
        --ephemeral-storage "Size=${config.ephemeral_storage}" | jq .\n`;
    }

    // Tags
    if (config.tags && Object.keys(config.tags).length > 0) {
      commands += `\n# Set tags\n`;
      const tags = Object.entries(config.tags)
        .map(([key, value]) => `${key}=${value}`)
        .join(',');
      commands += `aws lambda tag-resource --resource "\$(aws lambda get-function --function-name ${functionName} --query 'Configuration.FunctionArn' --output text)" --tags ${tags} | jq .\n`;
    }

    return commands;
  }

  private generatePermissionsSection(functionName: string, config: LambdaConfig): string {
    if (!config.permissions || config.permissions.length === 0) {
      return '';
    }

    let section = '\n# Add permissions\n';
    config.permissions.forEach((permission, index) => {
      const statementId = permission.statement_id || `${permission.service || 'custom'}-${index}`;
      const action = permission.action || 'lambda:InvokeFunction';
      
      // Use explicit principal if provided, otherwise derive from service
      let principal: string;
      if (permission.principal) {
        principal = permission.principal;
      } else if (permission.service) {
        principal = this.getPrincipalForService(permission.service);
      } else {
        throw new Error(`Permission at index ${index} must specify either 'principal' or 'service'`);
      }
      
      section += `aws lambda add-permission \\
        --function-name ${functionName} \\
        --statement-id ${statementId} \\
        --action ${action} \\
        --principal ${principal}`;
      
      if (permission.source_arn) {
        section += ` \\
        --source-arn ${permission.source_arn}`;
      }
      
      section += ' | jq .\n';
    });

    return section;
  }

  private getPrincipalForService(service: string): string {
    const servicePrincipals: Record<string, string> = {
      'apigateway': 'apigateway.amazonaws.com',
      'events': 'events.amazonaws.com',
      'sns': 'sns.amazonaws.com',
      'sqs': 'sqs.amazonaws.com',
      's3': 's3.amazonaws.com',
      'cloudwatch': 'events.amazonaws.com',
      'iot': 'iot.amazonaws.com',
      'logs': 'logs.amazonaws.com',
      'elasticloadbalancing': 'elasticloadbalancing.amazonaws.com',
      'cognito': 'cognito-idp.amazonaws.com',
      'alexa': 'alexa-appkit.amazon.com',
      'lex': 'lex.amazonaws.com',
      'config': 'config.amazonaws.com',
      'cloudformation': 'cloudformation.amazonaws.com',
      'kinesis': 'kinesis.amazonaws.com',
      'dynamodb': 'dynamodb.amazonaws.com',
      'codecommit': 'codecommit.amazonaws.com',
      'codebuild': 'codebuild.amazonaws.com',
      'codepipeline': 'codepipeline.amazonaws.com',
    };

    return servicePrincipals[service] || service;
  }

  private generateLogGroupSection(functionName: string, config: LambdaConfig): string {
    let section = '';

    // Only create log group if auto_create_log_group is true (default)
    if (config.auto_create_log_group !== false) {
      section += `
# ロググループが存在しなければ作成する
if ! aws logs describe-log-groups \\
    --log-group-name-prefix /aws/lambda/${functionName} \\
    --query "logGroups[?logGroupName=='/aws/lambda/${functionName}'].logGroupName" \\
    --output text | grep -q "^/aws/lambda/${functionName}$"; then
    echo "Creating log group for ${functionName}"
    aws logs create-log-group --log-group-name /aws/lambda/${functionName} | jq .
fi

# ログ保持期間を設定
aws logs put-retention-policy --log-group-name /aws/lambda/${functionName} --retention-in-days ${config.log_retention_days || 7} | jq .
`;
    }

    return section;
  }

  async saveScript(outputPath: string, script: string): Promise<string> {
    const scriptPath = path.resolve(outputPath);
    await fs.writeFile(scriptPath, script, { mode: 0o755 });
    this.logger.verbose(`Deploy script saved: ${scriptPath}`);
    return scriptPath;
  }

  async cleanupScript(scriptPath: string): Promise<void> {
    try {
      await fs.unlink(scriptPath);
      this.logger.verbose(`Cleaned up script: ${scriptPath}`);
    } catch (error) {
      this.logger.verbose(`Failed to clean up script: ${scriptPath}`);
    }
  }
}
